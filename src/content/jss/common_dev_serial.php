<li><b>uart</b> - 1 if this device communicates via an UART (Universal Asynchronous Receiver-Transmitter). In real hardware, this means the communication happens at byte level and the UART is responsible for serializing and deserializing data. From a simulation point of view communication happens at byte level without any serialization.</li>
<li><b>uart_receive_complement</b> - 1 if the received data must be complemented before being passed to the next level. This value is usually set to 0.</li>
<li><b>uart_send_complement</b> - 1 if the data to be sent needs to be complemented. This value is usually set to 0.</li>
<li><b>uart_status_data_send_ready_bit</b> - indicates which be will be set in the status register to indicate that data is available to be sent. This value is usually 0. In certain architectures, multiple serial devices (up to 8) can be connected on the same status cable, thus each device must use a different wire for its own data send ready bit.</li>
<li><b>transmit_bit_number</b> - if uart is set to 0, communication happens at bit level. This value is usually set to 0. However, if multiple serial devices (up to 8) will share the same data cable, this value indicates on which wire the bit will be sent.</li>
<li><b>receive_bit_number</b> - if uart is set to 0, communication happens at bit level. This value is usually set to 0. However, if multiple serial devices (up to 8) will share the same data cable, this value indicates from which wire the bit will be read.</li>
<li><b>bit_send_complement</b> - if uart is set to 0, communication happens at bit level. If this value is set to 1, the current bit will be inverted before being sent.</li>
<li><b>bit_transmit_empty</b> - if uart is set to 0, communication happens at bit level. This value indicates what will be sent when there is no available data. This is useful if the software doesn't check the status register or reads data regardless of the status register value.</li>
<li><b>map_codes_from</b>, <b>map_codes_to</b> - these two options allows to setup a mapping of character codes to be used during send and receive. Both options contain a list of comma separated hex values, associated with characters. When sending, characters from "map_codes_from" will be mapped to characters in "map_codes_to". When receiving, characters from "map_codes_to" will be mapped to characters in "map_codes_from". Mappings are set in the order in which they appear in the lists. One usage is to force setting bit number 7 on certain regular ASCII characters. Another use case is for converting lowercase characters into uppercase characters when sending data. In this case, in order to avoid converting to lowercase when receiving, it is important to include also the uppercase-to-uppercase mapping, like this: "map_codes_from"="61,62,41,42", "map_codes_to"="41,42,41,42" (this example converts only "a" and "b" to "A" and "B").</li>
<li><b>receive_ignore_bit_7</b> - if set to 1, will ignore the value associated with bit 7 when data is received.</li>
<li><b>transmit_set_bit_7</b> - if set to 1, will always set bit number 7 to 1, when data is sent.</li>


